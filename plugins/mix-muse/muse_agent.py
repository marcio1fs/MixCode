#!/usr/bin/env python3
"""
Mix Muse Agent - Python Backend
Agente de IA musical que analisa código e gera padrões musicais
"""

import json
import re
import math
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from enum import Enum

class MusicStyle(Enum):
    JAZZ = "jazz"
    CLASSICAL = "classical"
    ELECTRONIC = "electronic"
    ROCK = "rock"
    AMBIENT = "ambient"

class Complexity(Enum):
    SIMPLE = "simple"
    MEDIUM = "medium"
    COMPLEX = "complex"

@dataclass
class MusicalPattern:
    rhythm: str
    harmony: str
    melody: str
    structure: str
    tempo: int
    key: str
    time_signature: str

@dataclass
class CodeAnalysis:
    lines: int
    functions: int
    classes: int
    loops: int
    conditionals: int
    complexity_score: float
    musical_characteristics: Dict[str, any]

class MuseAgent:
    def __init__(self, music_style: MusicStyle = MusicStyle.JAZZ, 
                 tempo: int = 120, complexity: Complexity = Complexity.MEDIUM):
        self.music_style = music_style
        self.tempo = tempo
        self.complexity = complexity
        self.scales = {
            'jazz': ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            'classical': ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            'electronic': ['C', 'D#', 'F', 'F#', 'G#', 'A#'],
            'rock': ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            'ambient': ['C', 'D', 'E', 'F', 'G', 'A', 'B']
        }
        
    def analyze_code(self, code: str) -> CodeAnalysis:
        """Analisa o código e extrai características musicais"""
        lines = code.split('\n')
        functions = len(re.findall(r'function|def|class', code, re.IGNORECASE))
        classes = len(re.findall(r'class', code, re.IGNORECASE))
        loops = len(re.findall(r'for|while', code, re.IGNORECASE))
        conditionals = len(re.findall(r'if|else|switch', code, re.IGNORECASE))
        
        # Calcular score de complexidade
        complexity_score = self._calculate_complexity_score(
            len(lines), functions, classes, loops, conditionals
        )
        
        # Características musicais
        musical_characteristics = {
            'rhythm_pattern': self._determine_rhythm_pattern(loops, conditionals),
            'harmonic_layers': self._determine_harmonic_layers(functions, classes),
            'melodic_scale': self._determine_melodic_scale(complexity_score),
            'structural_form': self._determine_structural_form(len(lines), functions)
        }
        
        return CodeAnalysis(
            lines=len(lines),
            functions=functions,
            classes=classes,
            loops=loops,
            conditionals=conditionals,
            complexity_score=complexity_score,
            musical_characteristics=musical_characteristics
        )
    
    def generate_musical_pattern(self, analysis: CodeAnalysis) -> MusicalPattern:
        """Gera um padrão musical baseado na análise do código"""
        
        # Determinar ritmo baseado em loops e condicionais
        rhythm = self._generate_rhythm(analysis.loops, analysis.conditionals)
        
        # Determinar harmonia baseada em funções e classes
        harmony = self._generate_harmony(analysis.functions, analysis.classes)
        
        # Determinar melodia baseada na complexidade
        melody = self._generate_melody(analysis.complexity_score)
        
        # Determinar estrutura baseada no estilo musical
        structure = self._generate_structure(analysis.lines, analysis.functions)
        
        # Determinar tempo baseado na complexidade
        tempo = self._adjust_tempo(analysis.complexity_score)
        
        # Determinar tonalidade baseada no estilo
        key = self._determine_key()
        
        # Determinar compasso baseado no ritmo
        time_signature = self._determine_time_signature(analysis.loops)
        
        return MusicalPattern(
            rhythm=rhythm,
            harmony=harmony,
            melody=melody,
            structure=structure,
            tempo=tempo,
            key=key,
            time_signature=time_signature
        )
    
    def generate_musical_code(self, pattern: MusicalPattern) -> str:
        """Gera código inspirado no padrão musical"""
        
        code_template = f'''
// Generated by Mix Muse - Musical Code Generator
// Style: {self.music_style.value}
// Tempo: {pattern.tempo} BPM
// Key: {pattern.key}
// Time Signature: {pattern.time_signature}

class MusicalCodeGenerator {{
    private tempo: number = {pattern.tempo};
    private key: string = '{pattern.key}';
    private timeSignature: string = '{pattern.time_signature}';
    private style: string = '{self.music_style.value}';
    
    constructor() {{
        this.initializeMusicalPattern();
    }}
    
    private initializeMusicalPattern() {{
        // Initialize based on musical analysis
        const rhythmPattern = this.createRhythmPattern();
        const harmonyLayers = this.createHarmonyLayers();
        const melodicElements = this.createMelodicElements();
        
        this.combineElements(rhythmPattern, harmonyLayers, melodicElements);
    }}
    
    private createRhythmPattern() {{
        return {{
            tempo: this.tempo,
            timeSignature: this.timeSignature,
            pattern: '{pattern.rhythm}'
        }};
    }}
    
    private createHarmonyLayers() {{
        return {{
            key: this.key,
            style: this.style,
            layers: '{pattern.harmony}'
        }};
    }}
    
    private createMelodicElements() {{
        return {{
            scale: this.getScale(),
            melody: '{pattern.melody}',
            structure: '{pattern.structure}'
        }};
    }}
    
    private combineElements(rhythm: any, harmony: any, melody: any) {{
        // Combine all musical elements into cohesive code structure
        console.log('Musical code generation complete');
        console.log('Rhythm:', rhythm);
        console.log('Harmony:', harmony);
        console.log('Melody:', melody);
    }}
    
    private getScale(): string[] {{
        const scales = {{
            jazz: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            classical: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            electronic: ['C', 'D#', 'F', 'F#', 'G#', 'A#'],
            rock: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            ambient: ['C', 'D', 'E', 'F', 'G', 'A', 'B']
        }};
        return scales[this.style] || scales.jazz;
    }}
}}

// Initialize the musical code generator
const musicalGenerator = new MusicalCodeGenerator();
'''
        
        return code_template
    
    def _calculate_complexity_score(self, lines: int, functions: int, 
                                  classes: int, loops: int, conditionals: int) -> float:
        """Calcula um score de complexidade baseado em métricas do código"""
        base_score = lines / 100.0  # Normalizar por 100 linhas
        function_density = functions / max(lines, 1)
        class_density = classes / max(lines, 1)
        control_flow = (loops + conditionals) / max(lines, 1)
        
        complexity = (base_score + function_density + class_density + control_flow) / 4
        return min(complexity, 1.0)  # Normalizar entre 0 e 1
    
    def _determine_rhythm_pattern(self, loops: int, conditionals: int) -> str:
        """Determina o padrão rítmico baseado em loops e condicionais"""
        total_control = loops + conditionals
        
        if total_control <= 2:
            return "4/4 steady beat"
        elif total_control <= 5:
            return "6/8 with syncopation"
        elif total_control <= 8:
            return "7/8 complex rhythm"
        else:
            return "polyrhythmic structure"
    
    def _determine_harmonic_layers(self, functions: int, classes: int) -> str:
        """Determina as camadas harmônicas baseadas em funções e classes"""
        total_structures = functions + classes
        
        if total_structures <= 3:
            return "simple triads"
        elif total_structures <= 6:
            return "extended chords (7ths)"
        elif total_structures <= 10:
            return "complex harmony (9ths, 11ths)"
        else:
            return "dense harmonic clusters"
    
    def _determine_melodic_scale(self, complexity: float) -> str:
        """Determina a escala melódica baseada na complexidade"""
        if complexity <= 0.3:
            return "pentatonic scale"
        elif complexity <= 0.6:
            return "diatonic scale"
        else:
            return "chromatic scale"
    
    def _determine_structural_form(self, lines: int, functions: int) -> str:
        """Determina a forma estrutural baseada no tamanho e organização"""
        if lines <= 50:
            return "simple song form"
        elif lines <= 150:
            return "verse-chorus structure"
        elif lines <= 300:
            return "complex song form"
        else:
            return "extended composition"
    
    def _generate_rhythm(self, loops: int, conditionals: int) -> str:
        """Gera descrição do ritmo"""
        style_rhythms = {
            MusicStyle.JAZZ: "swing rhythm with syncopation",
            MusicStyle.CLASSICAL: "structured rhythmic patterns",
            MusicStyle.ELECTRONIC: "electronic beats with samples",
            MusicStyle.ROCK: "driving rock rhythm",
            MusicStyle.AMBIENT: "free-flowing ambient rhythm"
        }
        
        base_rhythm = style_rhythms.get(self.music_style, "standard rhythm")
        complexity_modifier = "complex" if loops + conditionals > 5 else "simple"
        
        return f"{complexity_modifier} {base_rhythm}"
    
    def _generate_harmony(self, functions: int, classes: int) -> str:
        """Gera descrição da harmonia"""
        style_harmonies = {
            MusicStyle.JAZZ: "extended jazz chords",
            MusicStyle.CLASSICAL: "traditional classical harmony",
            MusicStyle.ELECTRONIC: "synthesized electronic harmony",
            MusicStyle.ROCK: "power chord rock harmony",
            MusicStyle.AMBIENT: "atmospheric pad harmony"
        }
        
        base_harmony = style_harmonies.get(self.music_style, "standard harmony")
        layer_count = functions + classes
        
        return f"{base_harmony} with {layer_count} harmonic layers"
    
    def _generate_melody(self, complexity: float) -> str:
        """Gera descrição da melodia"""
        if complexity <= 0.3:
            return "simple melodic line"
        elif complexity <= 0.6:
            return "developed melodic theme"
        else:
            return "complex melodic variations"
    
    def _generate_structure(self, lines: int, functions: int) -> str:
        """Gera descrição da estrutura"""
        style_structures = {
            MusicStyle.JAZZ: "AABA form with improvisation",
            MusicStyle.CLASSICAL: "sonata form",
            MusicStyle.ELECTRONIC: "build-up and drop structure",
            MusicStyle.ROCK: "verse-chorus-bridge",
            MusicStyle.AMBIENT: "free-form atmospheric"
        }
        
        return style_structures.get(self.music_style, "standard structure")
    
    def _adjust_tempo(self, complexity: float) -> int:
        """Ajusta o tempo baseado na complexidade"""
        base_tempo = self.tempo
        
        if complexity <= 0.3:
            return base_tempo - 20  # Mais lento para código simples
        elif complexity <= 0.6:
            return base_tempo  # Tempo normal
        else:
            return base_tempo + 30  # Mais rápido para código complexo
    
    def _determine_key(self) -> str:
        """Determina a tonalidade baseada no estilo musical"""
        style_keys = {
            MusicStyle.JAZZ: "C major",
            MusicStyle.CLASSICAL: "D major",
            MusicStyle.ELECTRONIC: "F minor",
            MusicStyle.ROCK: "E major",
            MusicStyle.AMBIENT: "A minor"
        }
        
        return style_keys.get(self.music_style, "C major")
    
    def _determine_time_signature(self, loops: int) -> str:
        """Determina o compasso baseado nos loops"""
        if loops <= 2:
            return "4/4"
        elif loops <= 4:
            return "6/8"
        elif loops <= 6:
            return "7/8"
        else:
            return "5/4"

def suggest_names(code: str, symbols: list[str]) -> dict:
    """Sugere nomes mais expressivos para funções baseado em análise musical"""
    prompt = f"""
Você é um museu da engenharia de software com conhecimento em teoria musical. 
Analise o código e sugira nomes mais expressivos para as funções, considerando:

1. **Ritmo**: Nomes que fluem bem e têm cadência natural
2. **Harmonia**: Nomes que se relacionam bem entre si
3. **Melodia**: Nomes que contam uma história clara
4. **Estrutura**: Nomes que refletem a organização do código

Funções detectadas: {symbols}

Código:
{code}

Sugira nomes que sejam:
- Expressivos e descritivos
- Musicalmente harmoniosos
- Consistentes com o estilo do código
- Fáceis de pronunciar e lembrar

Responda apenas com os nomes sugeridos, um por linha.
"""
    
    # Simular resposta da IA (em implementação real, chamaria ask_openai)
    response = f"""
# Sugestões de nomes baseadas em análise musical:

## Funções principais:
{symbols[0] if symbols else 'main'} -> orchestrate_flow
{symbols[1] if len(symbols) > 1 else 'process'} -> harmonize_data
{symbols[2] if len(symbols) > 2 else 'calculate'} -> compose_result

## Funções auxiliares:
validate_input -> tune_parameters
format_output -> arrange_presentation
handle_error -> resolve_dissonance

## Padrão musical aplicado:
- Ritmo: Nomes com sílabas bem distribuídas
- Harmonia: Nomes que se complementam
- Melodia: Nomes que fluem naturalmente
- Estrutura: Nomes que refletem hierarquia
"""
    
    return {"suggestions": response}

def analyze_naming_patterns(code: str) -> dict:
    """Analisa padrões de nomenclatura no código"""
    function_patterns = re.findall(r'function\s+(\w+)', code)
    method_patterns = re.findall(r'(\w+)\s*\([^)]*\)\s*{', code)
    
    all_names = function_patterns + method_patterns
    
    analysis = {
        'total_functions': len(all_names),
        'naming_patterns': [],
        'suggestions': []
    }
    
    # Analisar padrões de nomenclatura
    for name in all_names:
        if name.startswith('get'):
            analysis['naming_patterns'].append('getter_pattern')
        elif name.startswith('set'):
            analysis['naming_patterns'].append('setter_pattern')
        elif name.startswith('is'):
            analysis['naming_patterns'].append('boolean_pattern')
        elif name.startswith('handle'):
            analysis['naming_patterns'].append('event_handler_pattern')
        elif name.startswith('process'):
            analysis['naming_patterns'].append('processor_pattern')
        else:
            analysis['naming_patterns'].append('custom_pattern')
    
    return analysis

def main():
    """Função principal para teste do agente"""
    agent = MuseAgent(MusicStyle.JAZZ, 120, Complexity.MEDIUM)
    
    # Código de exemplo para teste
    sample_code = """
function calculateSum(a, b) {
    if (a > 0 && b > 0) {
        for (let i = 0; i < 10; i++) {
            console.log(i);
        }
        return a + b;
    }
    return 0;
}

class Calculator {
    constructor() {
        this.result = 0;
    }
    
    add(x, y) {
        return x + y;
    }
}
"""
    
    # Analisar código
    analysis = agent.analyze_code(sample_code)
    print(f"Análise do código:")
    print(f"  Linhas: {analysis.lines}")
    print(f"  Funções: {analysis.functions}")
    print(f"  Classes: {analysis.classes}")
    print(f"  Loops: {analysis.loops}")
    print(f"  Condicionais: {analysis.conditionals}")
    print(f"  Score de complexidade: {analysis.complexity_score:.2f}")
    
    # Gerar padrão musical
    pattern = agent.generate_musical_pattern(analysis)
    print(f"\nPadrão musical gerado:")
    print(f"  Ritmo: {pattern.rhythm}")
    print(f"  Harmonia: {pattern.harmony}")
    print(f"  Melodia: {pattern.melody}")
    print(f"  Estrutura: {pattern.structure}")
    print(f"  Tempo: {pattern.tempo} BPM")
    print(f"  Tonalidade: {pattern.key}")
    print(f"  Compasso: {pattern.time_signature}")
    
    # Testar sugestão de nomes
    symbols = ['calculateSum', 'add']
    naming_suggestions = suggest_names(sample_code, symbols)
    print(f"\nSugestões de nomes:")
    print(naming_suggestions['suggestions'])
    
    # Analisar padrões de nomenclatura
    naming_analysis = analyze_naming_patterns(sample_code)
    print(f"\nAnálise de nomenclatura:")
    print(f"  Total de funções: {naming_analysis['total_functions']}")
    print(f"  Padrões encontrados: {naming_analysis['naming_patterns']}")
    
    # Gerar código musical
    musical_code = agent.generate_musical_code(pattern)
    print(f"\nCódigo musical gerado:")
    print(musical_code)

if __name__ == "__main__":
    main() 